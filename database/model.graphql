# Prisma does not support interfaces nor union types yet, so we emulate it.
# https://www.prisma.io/docs/data-model-and-migrations/data-model-knul/#more-sdl-features
# TODO: Use custom scalars instead of Int and Float, e.g. 0-256, 0-1, etc.

# As for tree structure, we use parent/children because it's the most
# straightforward approach for now. We don't need recursive queries because we
# can fetch all related objects from App and resolve them in the client.
# Parents and children are enforced with referential integrity. In the future,
# I'd like to try closure tables, but Prisma doesn't support composite keys yet.
# So, it can be improved ofc but it's good enough for now.
# TODO: Detect parent/child circular references. Maybe closure tables prevent them.
# https://datubaze.files.wordpress.com/2016/03/celkos-trees-and-hierarchies-in-sql_2004.pdf
# https://coderwall.com/p/lixing/closure-tables-for-browsing-trees-in-sql

type User {
  # Props order: ID, own IDs, foreign IDs, scalars.
  id: ID! @unique
  webs: [Web!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String! @unique
  password: String!
  themeName: String
}

type Web {
  id: ID! @unique
  creator: User!
  pages: [Page!]! @relation(name: "WebPages")
  elements: [Element!]! @relation(name: "WebElements")
  styles: [Style!]! @relation(name: "WebStyles")
  dimensionValues: [DimensionValue!]! @relation(name: "WebDimensionValues")
  colorValues: [ColorValue!]! @relation(name: "WebColorValues")
  borderValues: [BorderValue!]! @relation(name: "WebBorderValues")
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  components: [Component!]! @relation(name: "WebComponents")
}

type Page {
  id: ID! @unique
  creator: User!
  web: Web! @relation(name: "WebPages")
  element: Element!
  createdAt: DateTime!
  updatedAt: DateTime!
  title: String!
}

# Should be called Node, but that's reserved word in Relay.
# Element is good enough abstraction for View Text Component.
# https://docs.slatejs.org/guides/data-model#documents-and-nodes
type Element {
  id: ID! @unique
  # https://github.com/prisma/prisma/issues/2034#issuecomment-421850503
  children: [Element!]! @relation(name: "ElementTree")
  parent: Element @relation(name: "ElementTree")
  web: Web! @relation(name: "WebElements")
  style: Style @relation(name: "ElementStyle")
  component: Component @relation(name: "ElementComponent")
  index: Int!
  type: ElementType!
  # Block or inline element can have children, style, or component, so we need
  # referential integrity, but text element is value object only with marks.
  # To simplify things, we consider marks as constants, only bold and italic
  # are allowed for now.
  # {
  #   object: 'text',
  #   leaves: [
  #     { object: 'leaf', text: ' and ', marks: [] },
  #     {
  #       object: 'leaf',
  #       text: 'bold',
  #       marks: [{ object: 'mark', type: 'bold', data: {} }],
  #     },
  #     { object: 'leaf', text: '.', marks: [] },
  #   ],
  # },
  textLeaves: Json
}

enum ElementType {
  BLOCK
  INLINE
  TEXT
}

# https://github.com/facebook/react-native/blob/master/Libraries/StyleSheet/StyleSheetTypes.js
type Style {
  id: ID! @unique
  spreadStyles: [StyleSpread!]! @relation(name: "StyleSpreadStyles")

  # When the user presses the enter key on the end of a text.
  # Example: heading 1 -> paragraph
  nextStyle: Style @relation(name: "StyleNextStyle")
  web: Web! @relation(name: "WebStyles")
  elements: [Element!]! @relation(name: "ElementStyle")
  name: String!
  isText: Boolean @default(value: "false")

  # View
  display: StyleDisplay
  width: DimensionValue @relation(name: "StyleWidth")
  height: DimensionValue @relation(name: "StyleHeight")
  bottom: DimensionValue @relation(name: "StyleBottom")
  end: DimensionValue @relation(name: "StyleEnd")
  left: DimensionValue @relation(name: "StyleLeft")
  right: DimensionValue @relation(name: "StyleRight")
  start: DimensionValue @relation(name: "StyleStart")
  top: DimensionValue @relation(name: "StyleTop")
  minWidth: DimensionValue @relation(name: "StyleMinWidth")
  maxWidth: DimensionValue @relation(name: "StyleMaxWidth")
  minHeight: DimensionValue @relation(name: "StyleMinHeight")
  maxHeight: DimensionValue @relation(name: "StyleMaxHeight")
  margin: DimensionValue @relation(name: "StyleMargin")
  marginBottom: DimensionValue @relation(name: "StyleMarginBottom")
  marginEnd: DimensionValue @relation(name: "StyleMarginEnd")
  marginHorizontal: DimensionValue @relation(name: "StyleMarginHorizontal")
  marginLeft: DimensionValue @relation(name: "StyleMarginLeft")
  marginRight: DimensionValue @relation(name: "StyleMarginRight")
  marginStart: DimensionValue @relation(name: "StyleMarginStart")
  marginTop: DimensionValue @relation(name: "StyleMarginTop")
  marginVertical: DimensionValue @relation(name: "StyleMarginVertical")
  padding: DimensionValue @relation(name: "StylePadding")
  paddingBottom: DimensionValue @relation(name: "StylePaddingBottom")
  paddingEnd: DimensionValue @relation(name: "StylePaddingEnd")
  paddingHorizontal: DimensionValue @relation(name: "StylePaddingHorizontal")
  paddingLeft: DimensionValue @relation(name: "StylePaddingLeft")
  paddingRight: DimensionValue @relation(name: "StylePaddingRight")
  paddingStart: DimensionValue @relation(name: "StylePaddingStart")
  paddingTop: DimensionValue @relation(name: "StylePaddingTop")
  paddingVertical: DimensionValue @relation(name: "StylePaddingVertical")
  position: StylePosition
  flexDirection: StyleFlexDirection
  flexWrap: StyleFlexWrap
  justifyContent: StyleJustifyContent
  alignItems: StyleAlignItems
  alignSelf: StyleAlignSelf
  alignContent: StyleAlignContent
  overflow: StyleOverflow
  flex: Int
  flexGrow: Int
  flexShrink: Int
  # flexBasis can be number or 'auto', but Prisma doesn't support union types
  # yet. Therefore, -1 is considered to be 'auto'.
  flexBasis: Int
  zIndex: Int
  direction: StyleDirection
  backgroundColor: ColorValue @relation(name: "StyleBackgroundColor")
  borderColor: ColorValue @relation(name: "StyleBorderColor")
  borderBottomColor: ColorValue @relation(name: "StyleBorderBottomColor")
  borderEndColor: ColorValue @relation(name: "StyleBorderEndColor")
  borderLeftColor: ColorValue @relation(name: "StyleBorderLeftColor")
  borderRightColor: ColorValue @relation(name: "StyleBorderRightColor")
  borderStartColor: ColorValue @relation(name: "StyleBorderStartColor")
  borderTopColor: ColorValue @relation(name: "StyleBorderTopColor")
  borderRadius: BorderValue @relation(name: "StyleBorderRadius")
  borderBottomEndRadius: BorderValue
    @relation(name: "StyleBorderBottomEndRadius")
  borderBottomLeftRadius: BorderValue
    @relation(name: "StyleBorderBottomLeftRadius")
  borderBottomRightRadius: BorderValue
    @relation(name: "StyleBorderBottomRightRadius")
  borderBottomStartRadius: BorderValue
    @relation(name: "StyleBorderBottomStartRadius")
  borderTopEndRadius: BorderValue @relation(name: "StyleBorderTopEndRadius")
  borderTopLeftRadius: BorderValue @relation(name: "StyleBorderTopLeftRadius")
  borderTopRightRadius: BorderValue @relation(name: "StyleBorderTopRightRadius")
  borderTopStartRadius: BorderValue @relation(name: "StyleBorderTopStartRadius")
  borderStyle: StyleBorderStyle
  borderWidth: BorderValue @relation(name: "StyleBorderWidth")
  borderBottomWidth: BorderValue @relation(name: "StyleBorderBottomWidth")
  borderEndWidth: BorderValue @relation(name: "StyleBorderEndWidth")
  borderLeftWidth: BorderValue @relation(name: "StyleBorderLeftWidth")
  borderRightWidth: BorderValue @relation(name: "StyleBorderRightWidth")
  borderStartWidth: BorderValue @relation(name: "StyleBorderStartWidth")
  borderTopWidth: BorderValue @relation(name: "StyleBorderTopWidth")
  opacity: Int
  # Text
  color: ColorValue @relation(name: "StyleColor")
  fontFamily: String
  fontSize: Int
  fontStyle: StyleFontStyle
  fontWeight: StyleFontWeight
  fontVariant: StyleFontVariant
  letterSpacing: Int
  lineHeight: Int
  textAlign: StyleTextAlign
  textAlignVertical: StyleTextAlignVertical
  textDecorationLine: StyleTextDecorationLine
  textTransform: StyleTextTransform

  # TODO: Add missing props.
}

# Spread styles like in JS (it is JS). Make bigger styles from smaller.
# Or override. Style composition over inheritance. Reactive CSS ftw.
# text -> heading, button => active button
# The point is, we can extends more styles.
# Classical inheritance: paragraph = { ...text, marginBottom: 24 }
# But what if we want to reuse marginBottom: 24 or something else?
# for marginBottom, we can use marginBottom: defaultBlockBottom constant.
# But what if we want to reuse more props? Then we are doomed. Or we can spread.
# paragraph = { ...text, marginBottom: 24 }
# Spread is useful for "utility classes" like .center, .whatever etc.
# https://adamwathan.me/css-utility-classes-and-separation-of-concerns/
# https://frontstuff.io/in-defense-of-utility-first-css
type StyleSpread {
  id: ID! @unique
  spreadStyle: Style! @relation(name: "StyleSpreadStyles")
  index: Int!
  style: Style! @relation(name: "SpreadStyle")
}

type DimensionValue {
  id: ID! @unique
  web: Web! @relation(name: "WebDimensionValues")
  name: String
  unit: DimensionValueUnit!
  value: Int!
}

enum DimensionValueUnit {
  POINT
  PERCENTAGE
  # 'auto' - value: 1
  KEYWORD
}

type ColorValue {
  id: ID! @unique
  web: Web! @relation(name: "WebColorValues")
  name: String
  r: Int!
  g: Int!
  b: Int!
  a: Float
}

type BorderValue {
  id: ID! @unique
  web: Web! @relation(name: "WebBorderValues")
  name: String
  unit: BorderValueUnit!
  value: Int!
}

enum BorderValueUnit {
  POINT
}

enum StyleDisplay {
  NONE
  FLEX
}

enum StylePosition {
  ABSOLUTE
  RELATIVE
}

enum StyleFlexDirection {
  ROW
  ROW_REVERSE
  COLUMN
  COLUMN_REVERSE
}

enum StyleFlexWrap {
  WRAP
  NOWRAP
  WRAP_REVERSE
}

enum StyleJustifyContent {
  FLEX_START
  FLEX_END
  CENTER
  SPACE_BETWEEN
  SPACE_AROUND
  SPACE_EVENLY
}

enum StyleAlignItems {
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  BASELINE
}

enum StyleAlignSelf {
  AUTO
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  BASELINE
}

enum StyleAlignContent {
  FLEX_START
  FLEX_END
  CENTER
  STRETCH
  SPACE_BETWEEN
  SPACE_AROUND
}

enum StyleOverflow {
  VISIBLE
  HIDDEN
  SCROLL
}

enum StyleDirection {
  INHERIT
  LTR
  RTL
}

enum StyleBorderStyle {
  SOLID
  DOTTED
  DASHED
}

enum StyleFontStyle {
  NORMAL
  ITALIC
}

enum StyleFontWeight {
  NORMAL
  BOLD
  # Integers must be prefixed to be valid GraphQL enum value.
  INT_100
  INT_200
  INT_300
  INT_400
  INT_500
  INT_600
  INT_700
  INT_800
  INT_900
}

enum StyleFontVariant {
  SMALL_CAPS
}

enum StyleTextAlign {
  AUTO
  LEFT
  RIGHT
  CENTER
  JUSTIFY
}

enum StyleTextAlignVertical {
  AUTO
  TOP
  BOTTOM
  CENTER
}

enum StyleTextDecorationLine {
  NONE
  UNDERLINE
  LINE_THROUGH
  UNDERLINE_LINE_THROUGH
}

enum StyleTextTransform {
  NONE
  CAPITALIZE
  UPPERCASE
  LOWERCASE
}

type Component {
  id: ID! @unique
  web: Web! @relation(name: "WebComponents")
  elements: [Element!]! @relation(name: "ElementComponent")
  name: String!
}
