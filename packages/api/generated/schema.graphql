### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type AggregateTada {
  count: Int!
}

type AggregateUser {
  count: Int!
}

"""Use JavaScript Date object for date/time fields."""
scalar DateTime

enum EmailError {
  ALREADY_EXISTS
  EMAIL
  NOT_EXISTS
  REQUIRED
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

enum Max140CharsError {
  MAX_140_CHARS
  REQUIRED
}

type Mutation {
  createTada(input: TadaCreateInput!): TadaCreatePayload!
  deleteTada(input: TadaDeleteInput!): TadaDeletePayload!
  setUserTheme(input: SetUserThemeInput!): SetUserThemePayload!
  signIn(input: SignInInput!): SignInPayload!
  updateTada(input: TadaUpdateInput!): TadaUpdatePayload!
}

enum MutationType {
  CREATED
  DELETED
  UPDATED
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PageSubcriptionFilters {
  first: Int!
  rootDataId: ID!
  skip: Int! = 0
}

enum PasswordError {
  MAX_1024_CHARS
  MIN_5_CHARS
  REQUIRED
  WRONG_PASSWORD
}

type Query {
  requiredViewer: User
  tada(id: ID!): Tada
  user(id: ID!): User
  viewer: User
}

input SetUserThemeInput {
  name: String!
}

type SetUserThemePayload {
  user: User
}

type SignInErrors {
  email: EmailError
  password: PasswordError
}

input SignInInput {
  createAccount: Boolean!
  email: String!
  password: String!
}

type SignInPayload {
  errors: SignInErrors
  token: String
}

type Subscription {
  userTadasConnection(filters: PageSubcriptionFilters!): TadaConnection!
  viewerAccessibleTadaUpdated: TadaSubscriptionPayload!
}

type Tada {
  createdAt: DateTime!
  creator: User!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type TadaConnection {
  aggregate: AggregateTada!
  edges: [TadaEdge!]!
  pageInfo: PageInfo!
}

type TadaCreateErrors {
  name: Max140CharsError
}

input TadaCreateInput {
  description: String
  name: String!
}

type TadaCreatePayload {
  errors: TadaCreateErrors
  tada: Tada
}

input TadaDeleteInput {
  id: ID!
}

type TadaDeletePayload {
  tada: Tada
}

type TadaEdge {
  cursor: String!
  node: Tada!
}

type TadaPreviousValues {
  createdAt: DateTime!
  description: String
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type TadaSubscriptionPayload {
  mutation: MutationType!
  node: Tada
  previousValues: TadaPreviousValues
  previousValuesAsTada: Tada
  updatedFields: [String!]
}

type TadaUpdateErrors {
  name: Max140CharsError
}

input TadaUpdateInput {
  description: String
  id: ID!
  name: String
}

type TadaUpdatePayload {
  errors: TadaUpdateErrors
  tada: Tada
}

input TadaWhereInput {
  AND: [TadaWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  creator: UserWhereInput
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TadaWhereInput!]
  OR: [TadaWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

type Team {
  createdAt: DateTime!
  description: String
  id: ID!
  members(after: String, before: String, first: Int, last: Int, orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]
  name: String!
  updatedAt: DateTime!
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  members_every: UserWhereInput
  members_none: UserWhereInput
  members_some: UserWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

enum URLError {
  REQUIRED
  URL
}

type User {
  createdAt: DateTime!
  email: String!
  id: ID!
  tadas(first: Int!, skip: Int): TadaConnection!
  team: Team
  teammates(first: Int!): UserConnection!
  themeName: String!
  updatedAt: DateTime!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  email_ASC
  email_DESC
  id_ASC
  id_DESC
  password_ASC
  password_DESC
  themeName_ASC
  themeName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  email: String
  email_contains: String
  email_ends_with: String
  email_gt: String
  email_gte: String
  email_in: [String!]
  email_lt: String
  email_lte: String
  email_not: String
  email_not_contains: String
  email_not_ends_with: String
  email_not_in: [String!]
  email_not_starts_with: String
  email_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  tadas_every: TadaWhereInput
  tadas_none: TadaWhereInput
  tadas_some: TadaWhereInput
  team: TeamWhereInput
  themeName: String
  themeName_contains: String
  themeName_ends_with: String
  themeName_gt: String
  themeName_gte: String
  themeName_in: [String!]
  themeName_lt: String
  themeName_lte: String
  themeName_not: String
  themeName_not_contains: String
  themeName_not_ends_with: String
  themeName_not_in: [String!]
  themeName_not_starts_with: String
  themeName_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}
